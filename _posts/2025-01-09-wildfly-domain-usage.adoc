---
layout: post
title:  "An introduction to use the domain mode of WildFly 34"
date:   2025-01-09
tags:   wildfly domain
author: liweinan
description: An introduction to use the domain mode of WildFly 34
---

I recently tried to play with the domain mode in the current release of WildFly, version 34, while writing this blog post.

I won’t explain much about the concept of WildFly’s domain mode. I have written a book before explaining the domain mode usage of WildFly usage in beforefootnote:[https://www.packtpub.com/en-us/product/jboss-eap6-high-availability-9781783282449?srsltid=AfmBOooUR6olUaY8qVHB6U70wb2oe_nAk8OloSeJAtkbn6AGgoQ7-OM9[JBoss EAP6 High Availability | Programming | eBook]]. There is also relative document about the domain mode setupfootnote:[https://docs.wildfly.org/35/High_Availability_Guide.html[High Availability Guide]]. Nevertheless, the resources I could found are mostly outdated or doesn’t contain the step-by-step walkthrough about the minimal configuration to be done for using the domain mode of WildFly. Especially in the security configuration part related to Elytron, according to the blog post written by Brianfootnote:[https://www.wildfly.org/news/2021/10/05/WildFly25-Final-Released/[WildFly
25 is released!]]:

____
A key focus in WildFly 25 has been completing our migration away from the legacy security layer that dates back to JBoss AS and onto the https://wildfly-security.github.io/wildfly-elytron/[WildFly Elytron] based https://docs.wildfly.org/24/WildFly_Elytron_Security.html[security layer] introduced in WildFly 11. SE 17 does not provide packages that legacy security heavily relies upon, so the time has come to complete the transition off of legacy security.
____

So I’d like to briefly introduce the current usage of domain mode in the current version of WildFly. I won’t cover all the detail usages of the domain mode in this blog post, but it will be a good start to follow the example introduced in this article for the further studies.

The first step is to download the current version of WildFly. I will use version `34.0.1.Final` version in this blog post which is the newest final version when I’m writing this blog post. Here is the release page:

* https://github.com/wildfly/wildfly/releases/tag/34.0.1.Final[Release 34.0.1.Final · wildfly/wildfly]

We can download the zip file of the release and extract it locally to use it. Here is my local environment setup:

image:2025-01-wildfly-domain/01.png[image]

As the deployment diagram shows above, I used two machines to run the WildFly server in domain mode. In the above setup, the WildFly server run on Machine A acts as a domain controller, and the WildFly server on Machine B will be connected to Machine A accepting the management from the domain server.

The hostname of the WildFly server running on Machine A will be configured to `primary`(this will be defined in the `name` property in the `host.xml`), and the hostname of the WildFly server running on Machine B will be configured to `secondary`. In both the WildFly servers running on the two different machines, they will be configured to run the `server` (This is the `server` section configured in the `host.xml`) in the same server group called `other-server-group`. The `primary` host will define a `server-three` server, and the `secondary` host will define a `server-two` server, and both belong to the `other-server-group`. In this way, the domain controller can manage this server group, and deploy a sample project into the `servers` belonging to the server group, though the `servers` are running on different hosts. I will explain the details step by step.

First I need to download and extract the WildFly 34 distribution into both machines so I can use them. The extracted WildFly server directory has some of the configuration files out-of-box. Here are the domain configurations provided:

[source,bash]
----
❯ ls wildfly-34.0.1.Final/domain/configuration/
application-roles.properties            host-secondary.xml
application-users.properties            host.xml
default-server-logging.properties       logging.properties
domain.xml                              mgmt-groups.properties
host-primary.xml                        mgmt-users.properties
----

From the above command output, we can see in the `wildfly-34.0.1.Final/domain/configuration/` directory, it contains `host-primary.xml` and `host-secondary.xml` files. I will use `host-secondary.xml` with some modifications in Machine B. However, I’ll use the `host.xml` instead of `host-primary.xml` in Machine A, because `host-primary.xml` has removed all the `servers` configuration which only acts as a domain controller. However, I still need to run the server in Machine A for demonstration purposes.

First, let’s check the `host.xml` on Machine A to fit the requirement. In `host.xml`, the hostname is set to `primary` by default:

[source,xml]
----
<host xmlns="urn:jboss:domain:community:20.0" name="primary">
----

This is what I expect, so I don’t need to change it. The `host.xml` has two servers settings by default:

[source,xml]
----
<server name="server-one" group="main-server-group"/>
<server name="server-two" group="main-server-group" auto-start="true">
    <jvm name="default"/>
    <socket-bindings port-offset="150"/>
</server>
<server name="server-three" group="other-server-group" auto-start="false">
    <jvm name="default"/>
    <socket-bindings port-offset="250"/>
</server>
----

I’ll use only `server-three` in this blog post, so I comment out the `server-one` and the `server-two` definitions and only leave the `server-three` definition here. In addition, there are several interface properties defined in the `host.xml` file that we need to override during runtime. Here is the `interfaces` section in the `host.xml`:

[source,xml]
----
<interfaces>
    <interface name="management">
        <inet-address value="${jboss.bind.address.management:127.0.0.1}"/>
    </interface>
    <interface name="public">
        <inet-address value="${jboss.bind.address:127.0.0.1}"/>
    </interface>
</interfaces>
----

I checked my IP address of Machine A and it’s `192.168.0.115`, so I started the WildFly Server on Machine A by running the following commands in the `bin` directory of WildFly:

[source,bash]
----
$ pwd
/Volumes/data/works/wildfly-34.0.1.Final/bin
----

[source,bash]
----
$ ./domain.sh --host-config=host.xml -Djboss.bind.address.management=192.168.0.115 -Djboss.bind.address=192.168.0.115 -Djboss.domain.primary.address=192.168.0.115
----

And I can see the server is started and here is the server log output of the above command:

[source,bash]
----
=========================================================================

  JBoss Bootstrap Environment

  JBOSS_HOME: /Volumes/data/works/wildfly-34.0.1.Final

  JAVA: /Users/weli/.sdkman/candidates/java/current/bin/java

  JAVA_OPTS: -Xms64m -Xmx512m -XX:MaxMetaspaceSize=256m -Djava.net.preferIPv4Stack=true -Djboss.modules.system.pkgs=org.jboss.byteman -Djava.awt.headless=true -Djdk.serialFilter="maxbytes=10485760;maxdepth=128;maxarray=100000;maxrefs=300000"  --add-exports=java.desktop/sun.awt=ALL-UNNAMED --add-exports=java.naming/com.sun.jndi.ldap=ALL-UNNAMED --add-exports=java.naming/com.sun.jndi.url.ldap=ALL-UNNAMED --add-exports=java.naming/com.sun.jndi.url.ldaps=ALL-UNNAMED --add-exports=jdk.naming.dns/com.sun.jndi.dns=ALL-UNNAMED --add-opens=java.base/java.lang=ALL-UNNAMED --add-opens=java.base/java.lang.invoke=ALL-UNNAMED --add-opens=java.base/java.lang.reflect=ALL-UNNAMED --add-opens=java.base/java.io=ALL-UNNAMED --add-opens=java.base/java.net=ALL-UNNAMED --add-opens=java.base/java.security=ALL-UNNAMED --add-opens=java.base/java.util=ALL-UNNAMED --add-opens=java.base/java.util.concurrent=ALL-UNNAMED --add-opens=java.management/javax.management=ALL-UNNAMED --add-opens=java.naming/javax.naming=ALL-UNNAMED -Djava.security.manager=allow

=========================================================================

01:17:26,865 INFO  [org.jboss.modules] (main) JBoss Modules version 2.1.5.Final
01:17:27,276 INFO  [org.jboss.threads] (main) JBoss Threads version 2.4.0.Final
01:17:27,316 INFO  [org.jboss.as.process.Host Controller.status] (main) WFLYPC0018: Starting process 'Host Controller'
01:17:27,750 INFO  [org.jboss.as.process.Host Controller.system.stdout] (stdout for Host Controller) [Host Controller] 01:17:27,732 INFO  [org.jboss.modules] (main) JBoss Modules version 2.1.5.Final
[Host Controller] 01:17:28,272 INFO  [org.jboss.msc] (main) JBoss MSC version 1.5.5.Final
[Host Controller] 01:17:28,280 INFO  [org.jboss.threads] (main) JBoss Threads version 2.4.0.Final
[Host Controller] 01:17:28,335 INFO  [org.jboss.as] (MSC service thread 1-2) WFLYSRV0049: WildFly 34.0.1.Final (WildFly Core 26.0.1.Final) starting
[Host Controller] 01:17:28,744 INFO  [org.wildfly.security] (Controller Boot Thread) ELY00001: WildFly Elytron version 2.6.0.Final
[Host Controller] 01:17:29,049 INFO  [org.jboss.as.host.controller] (Controller Boot Thread) WFLYHC0003: Creating http management service using network interface (management) port (9990) securePort (-1)
[Host Controller] 01:17:29,063 INFO  [org.xnio] (MSC service thread 1-5) XNIO version 3.8.16.Final
[Host Controller] 01:17:29,069 INFO  [org.xnio.nio] (MSC service thread 1-5) XNIO NIO Implementation Version 3.8.16.Final
[Host Controller] 01:17:29,112 INFO  [org.jboss.remoting] (MSC service thread 1-8) JBoss Remoting version 5.0.29.Final
[Host Controller] 01:17:30,516 INFO  [org.jboss.as] (Controller Boot Thread) WFLYSRV0062: Http management interface listening on http://192.168.0.115:9990/management and https://192.168.0.115:-1/management
[Host Controller] 01:17:30,516 INFO  [org.jboss.as] (Controller Boot Thread) WFLYSRV0053: Admin console listening on http://192.168.0.115:9990 and https://192.168.0.115:-1
[Host Controller] 01:17:30,566 INFO  [org.jboss.as] (Controller Boot Thread) WFLYSRV0025: WildFly 34.0.1.Final (WildFly Core 26.0.1.Final) (Host Controller) started in 3195ms - Started 70 of 71 services (14 services are lazy, passive or on-demand) - Host Controller configuration files in use: domain.xml, host.xml - Minimum feature stability level: community
----

From the above server log output, I can see the server-bound address is `192.168.0.115` instead of the default `127.0.0.1`. Then I opened another terminal window and ran the following command in the `bin` directory of the WildFly server:

....
$ ./add-user.sh -u admin -p 123
Added user 'admin' to file '/Volumes/data/works/wildfly-34.0.1.Final/standalone/configuration/mgmt-users.properties'
Added user 'admin' to file '/Volumes/data/works/wildfly-34.0.1.Final/domain/configuration/mgmt-users.properties'
....

From the above command output, we can see the `admin` user is added and its password is `123`. This added user will be used for the `secondary` server to connect to the `primary` server. Please note that we didn’t generate a secret value related to the generated `admin` user, which is already deprecated. So this kind of configuration on the `secondary` server of Machine B is deprecated:

[source,xml]
----
<server-identities>
  <secret value="..." />
</server-identities>
----

As the `primary` server is started on Machine A, now we can check the WildFly server configuration on Machine B. As planned, the WildFly server is named `secondary`, and the server will be connected to the `primary` server on Machine A, which acts as the domain controller.

In the `secondary` server on Machine B, it will use the `host-secondary.xml` as its server configuration. We need to make some modifications to this file. First I need to add the `name` property to the `host` section:

[source,xml]
----
<host xmlns="urn:jboss:domain:community:20.0" name="secondary">
----

Giving the host a name can help to analyze the server log output later. Then I need to add another configuration to the `domain-controller`:

[source,xml]
----
<remote authentication-context="myCtx">
----

As the configuration is shown above, I added a `remote` configuration into the `domain-controller` section, and I defined the `authentication-context` to be used as `myCtx`. This configuration is different than the legacy authentication before. So I need to define this `authentication-context` in the `elytron` subsystem. Here are the details:

[source,xml]
----
<profile>
    <subsystem xmlns="urn:jboss:domain:core-management:1.0"/>
    <subsystem xmlns="urn:wildfly:elytron:community:18.0" final-providers="combined-providers"
               disallowed-providers="OracleUcrypto" register-jaspi-factory="false">

        <authentication-client>
            <authentication-configuration sasl-mechanism-selector="DIGEST-MD5" name="myConfig"
                                          authentication-name="admin" realm="ManagementRealm">
                <credential-reference clear-text="123"/>
            </authentication-configuration>
            <authentication-context name="myCtx">
                <match-rule match-host="${jboss.domain.primary.address}" authentication-configuration="myConfig"/>
            </authentication-context>
        </authentication-client>
...
----

The above configuration shows how to configure the `elytron` subsystem to provide user `admin` and its password `123` for usage. The `authentication-configuration` section is added, and the authentication context `myCtx` is using this configuration. Please note this is only one way to provide `username` and `password` via the Elytron subsystem, and you can avoid using `clear-text` to provide the password. I won’t dig into more details on how to use Elytron in this blog post, but you can always refer to its document to learn its usage:

* https://docs.wildfly.org/34/WildFly_Elytron_Security.html[WildFly Elytron Security]

After configuring the authentication part in the `host-secondary.xml` file on Machine B, the last thing is that I disabled the `server-one` and left only `server-two` in the configuration:

[source,xml]
----
<servers>
    <!-- <server name="server-one" group="main-server-group"/> -->
    <server name="server-two" group="other-server-group">
        <socket-bindings port-offset="150"/>
    </server>
</servers>
----

Until now all the configurations are done, and then I can start the WildFly server on Machine B with the following command:

[source,bash]
----
❯ ./domain.sh --host-config=host-secondary.xml -Djboss.bind.address.management=192.168.0.113 -Djboss.bind.address=192.168.0.113 -Djboss.domain.primary.address=192.168.0.115
----

In the above command, I assign the value `host-secondary.xml` to the `host-config` property, and I assign values of `jboss.bind.address.management` and `jboss.bind.address` as `192.168.0.113`, which is the IP address of Machine B itself. I assigned the value of `jboss.domain.primary.address` as `192.168.0.115`, which is the IP address of Machine A. On Machine A, there is a WildFly server running as a domain controller as described above. Now we can see the server log output of the above command:

....
=========================================================================

  JBoss Bootstrap Environment

  JBOSS_HOME: /Users/weli/works/wildfly-34.0.1.Final

  JAVA: /Users/weli/.sdkman/candidates/java/current/bin/java

  JAVA_OPTS: -Xms64m -Xmx512m -XX:MaxMetaspaceSize=256m -Djava.net.preferIPv4Stack=true -Djboss.modules.system.pkgs=org.jboss.byteman -Djava.awt.headless=true -Djdk.serialFilter="maxbytes=10485760;maxdepth=128;maxarray=100000;maxrefs=300000"  --add-exports=java.desktop/sun.awt=ALL-UNNAMED --add-exports=java.naming/com.sun.jndi.ldap=ALL-UNNAMED --add-exports=java.naming/com.sun.jndi.url.ldap=ALL-UNNAMED --add-exports=java.naming/com.sun.jndi.url.ldaps=ALL-UNNAMED --add-exports=jdk.naming.dns/com.sun.jndi.dns=ALL-UNNAMED --add-opens=java.base/java.lang=ALL-UNNAMED --add-opens=java.base/java.lang.invoke=ALL-UNNAMED --add-opens=java.base/java.lang.reflect=ALL-UNNAMED --add-opens=java.base/java.io=ALL-UNNAMED --add-opens=java.base/java.net=ALL-UNNAMED --add-opens=java.base/java.security=ALL-UNNAMED --add-opens=java.base/java.util=ALL-UNNAMED --add-opens=java.base/java.util.concurrent=ALL-UNNAMED --add-opens=java.management/javax.management=ALL-UNNAMED --add-opens=java.naming/javax.naming=ALL-UNNAMED -Djava.security.manager=allow

=========================================================================

21:59:13,420 INFO  [org.jboss.modules] (main) JBoss Modules version 2.1.5.Final
21:59:13,571 INFO  [org.jboss.threads] (main) JBoss Threads version 2.4.0.Final
21:59:13,581 INFO  [org.jboss.as.process.Host Controller.status] (main) WFLYPC0018: Starting process 'Host Controller'
21:59:13,764 INFO  [org.jboss.as.process.Host Controller.system.stdout] (stdout for Host Controller) [Host Controller] 21:59:13,756 INFO  [org.jboss.modules] (main) JBoss Modules version 2.1.5.Final
[Host Controller] 21:59:13,929 INFO  [org.jboss.msc] (main) JBoss MSC version 1.5.5.Final
[Host Controller] 21:59:13,932 INFO  [org.jboss.threads] (main) JBoss Threads version 2.4.0.Final
[Host Controller] 21:59:13,949 INFO  [org.jboss.as] (MSC service thread 1-1) WFLYSRV0049: WildFly 34.0.1.Final (WildFly Core 26.0.1.Final) starting
[Host Controller] 21:59:14,092 INFO  [org.wildfly.security] (Controller Boot Thread) ELY00001: WildFly Elytron version 2.6.0.Final
[Host Controller] 21:59:14,194 INFO  [org.jboss.as.host.controller] (Controller Boot Thread) WFLYHC0003: Creating http management service using network interface (management) port (9990) securePort (-1)
[Host Controller] 21:59:14,199 INFO  [org.xnio] (MSC service thread 1-2) XNIO version 3.8.16.Final
[Host Controller] 21:59:14,201 INFO  [org.xnio.nio] (MSC service thread 1-2) XNIO NIO Implementation Version 3.8.16.Final
[Host Controller] 21:59:14,213 INFO  [org.jboss.remoting] (MSC service thread 1-2) JBoss Remoting version 5.0.29.Final
[Host Controller] 21:59:15,109 INFO  [org.jboss.as.host.controller] (Controller Boot Thread) WFLYHC0148: Connected to the domain controller at remote+http://192.168.0.115:9990
[Host Controller] 21:59:15,129 INFO  [org.jboss.as.host.controller] (Controller Boot Thread) WFLYHC0023: Starting server server-two
21:59:15,215 INFO  [org.jboss.as.process.Server:server-two.status] (ProcessController-threads - 3) WFLYPC0018: Starting process 'Server:server-two'
[Host Controller] 21:59:15,765 INFO  [org.jboss.as.host.controller] (management task-1) WFLYHC0021: Server [Server:server-two] connected using connection [Channel ID 23f153d4 (inbound) of Remoting connection 6dedcd4f to 192.168.0.113/192.168.0.113:56191 of endpoint "secondary:MANAGEMENT" <5416ddeb>]
[Host Controller] 21:59:15,779 INFO  [org.jboss.as.host.controller] (server-registration-threads - 1) WFLYHC0020: Registering server server-two
[Host Controller] 21:59:15,779 INFO  [org.jboss.as] (Controller Boot Thread) WFLYSRV0062: Http management interface listening on http://192.168.0.113:9990/management and https://192.168.0.113:-1/management
[Host Controller] 21:59:15,779 INFO  [org.jboss.as] (Controller Boot Thread) WFLYSRV0054: Admin console is not enabled
[Host Controller] 21:59:15,779 INFO  [org.jboss.as] (Controller Boot Thread) WFLYSRV0025: WildFly 34.0.1.Final (WildFly Core 26.0.1.Final) (Host Controller) started in 2176ms - Started 70 of 71 services (14 services are lazy, passive or on-demand) - Host Controller configuration file in use: host-secondary.xml - Minimum feature stability level: community
....

From the above server log output on Machine B, we can see the WildFly server is started and `server-two` is started. In addition it’s conneced to the `primary` server on Machine A. Here is the server log output from the WildFly server on Machine A:

....
[Host Controller] 21:59:15,093 INFO  [org.jboss.as.domain.controller] (Host Controller Service Threads - 26) WFLYHC0019: Registered remote secondary host "secondary", JBoss WildFly 34.0.1.Final (WildFly 26.0.1.Final)
....

From the above `primary` server log output, I can see the secondary host is connected, so it starts to accept the management of `primary` server, which acts as the domain controller. Now I can open the web browser on Machine A to access the WildFly server admin console:

....
http://192.168.0.115:9990
....

Please note that I can’t use the IP address `127.0.0.1` here, because the WildFly server is listening to the public IP address of Machine A, which we have assigned to the `jboss.bind.address.management` property during the server startup process. Here is the screenshot of the admin page of the WildFly server:

image:2025-01-wildfly-domain/02.png[image]

We need to enter `admin` as the username and `123` as the password, which is the user we added as the management user above. And then we can enter the admin page of the server:

image:2025-01-wildfly-domain/03.png[image]

As we have entered the WildFly admin page, we can try to upload an example project to the domain servers. There is a `helloworld` project in the WildFly Quickstart project:

* https://github.com/wildfly/quickstart/tree/main/helloworld[quickstart/helloworld at main · wildfly/quickstart]

The above project is a simple project that just contains a servlet that will respond with the text `<h1>Hello World!</h1>` to the request. So I cloned the WildFly Quickstart project into my local environment and then built the `helloworld` project to generate the `helloworld.war`:

[source,bash]
----
$ pwd
/Volumes/data/works/wildfly-quickstart/helloworld
----

[source,bash]
----
$ mvn install
...
[INFO] BUILD SUCCESS
...
----

[source,bash]
----
❯ ls target/*.war
target/helloworld.war
----

As the project is built, I can deploy the above WAR file into the WildFly server group. So I go back to the WildFly admin page, and then I can click the `Deployments` on the top menu and click the `Upload Deployment`:

image:2025-01-wildfly-domain/04.png[image]

From the above screenshot, you can see that I tried to deploy the sample project into the `other-server-group`. I use this server group because I have configured servers on both `primary` and `secondary` hosts into this server group. Here is the deployment diagram for the server group:

image:2025-01-wildfly-domain/05.png[image]

As the diagram shown above, I will use the domain controller’s admin page to deploy `helloworld.war` into the `other-server-group`, so the project will be deployed to `server-two` and `server-three`, because they both belong to `other-server-group`. Coming back to the WildFly admin page, I drag and drop the `helloworld.war` into the deployment page:

image:2025-01-wildfly-domain/06.png[image]

Then I clicked `Next` and left the deployment configuration fields as default:

image:2025-01-wildfly-domain/07.png[image]

Then I clicked `Finished` and reached the `Deployment successful` page:

image:2025-01-wildfly-domain/08.png[image]

Now the `helloworld.war` is deployed to all the `servers` in the `other-server-group`. Now I click the `Deployments` on the top menu of the admin page, and then click the `other-server-group`, we can see that the `helloworld.war` is deployed into the server group:

image:2025-01-wildfly-domain/09.png[image]

As the `helloworld` project is deployed, we can check the statuses of the two hosts. I clicked the `Runtime` on top of the menu of the admin page, and then clicked the `primary` host tab, then I saw that `server-three` has not started yet:

image:2025-01-wildfly-domain/10.png[image]

This is because the `auto-start` property is configured to `false` in the `host.xml` of the primary host:

[source,xml]
----
<server name="server-three" group="other-server-group" auto-start="false">
    <jvm name="default"/>
    <socket-bindings port-offset="250"/>
</server>
----

So I need to click the `Start` button of the `server-three`:

image:2025-01-wildfly-domain/11.png[image]

After a while the `server-three` is started:

image:2025-01-wildfly-domain/12.png[image]

Because we didn’t configure the `auto-start` to `false` on the
`secondary` host, so it’s already started:

image:2025-01-wildfly-domain/13.png[image]

From the above screenshots, we can see that the URL of `server-two` is `http://192.168.0.113:8230`, and the URL of `server-three` is `http://192.168.0.115:8330`. Their ports are different because the `port-offset` property settings are different. For `server-three`, the `port-offset` is configured like this:

[source,xml]
----
<server name="server-three" group="other-server-group" auto-start="false">
    <jvm name="default"/>
    <socket-bindings port-offset="250"/>
</server>
----

Because the `port-offset` is set to `250` for `server-three`, and the default HTTP port setting is `8080`, so `8080+250=8330`. For `server-two`, the configuration is like this:

[source,bash]
----
<server name="server-two" group="other-server-group">
    <socket-bindings port-offset="150"/>
</server>
----

As the `port-offset` setting is `150`, the calculated HTTP port is `8080+150=8330`, which is expected. Now we can use the `curl` command to do the requests to both the `primary` host and the `secondary` host to see if the `helloworld` project is deployed two both of the hosts:

[source,bash]
----
❯ curl http://192.168.0.115:8330/helloworld/HelloWorld
<html><head><title>helloworld</title></head><body>
<h1>Hello World!</h1>
</body></html>
----

[source,bash]
----
❯ curl http://192.168.0.113:8230/helloworld/HelloWorld
<html><head><title>helloworld</title></head><body>
<h1>Hello World!</h1>
</body></html>
----

From the above command output, we can see that the `helloworld` project is deployed two both hosts. Though they are running on two different machines, because these two hosts are in the same `other-server-group` and they are managed by the domain controller, so the project is deployed to both hosts.

I hope this blog post can be helpful to update your knowledge base to see how to use the domain mode in the most current WildFly release. For convenience, I have put the `host.xml` of the `primary` host and the `host-secondary.xml` of the `secondary` host online for referencefootnote:[https://gist.github.com/liweinan/6cca8f88203e5aa76d3c1516d1758421[WildFly Domain Mode Configuration Files]].

=== References
